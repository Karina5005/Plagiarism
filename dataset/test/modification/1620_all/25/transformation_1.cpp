#include <iomanip>
#include <iostream>
#include <bits/stdc++.h>
using namespace std;


#define pb push_back
#define eb emplace_back
#define mp make_pair
#define mt make_tuple
#define lb lower_bound
#define ub upper_bound
#define f first
#define s second
#define resz resize

#define sz(x) int((x).size())
#define all(x) (x).begin(), (x).end()

#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define F0R(i, a) for (int i = 0; i < (a); i++)
#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)
#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)
#define trav(a, x) for (auto& a : x)

#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })

using ll = long long;
using vi = vector<int>;
using vvi = vector<vi>;
using vll = vector<ll>;
using vvll = vector<vll>;
using vb = vector<bool>;
using vd = vector<double>;
using vs = vector<string>;

using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdd = pair<double, double>;

using vpii = vector<pii>;
using vpll = vector<pll>;
using vpdd = vector<pdd>;

template<typename T> void ckmin(T &a, const T &fa) ;
template<typename T> void ckmax(T &hcm_guu, const T &cg) ;

mt19937_64 kjy_t(chrono::steady_clock::now().time_since_epoch().count());

namespace __input {
    template<class T1, class T2> void re(pair<T1, T2> &b_ipv);
    template<class T> void re(vector<T> &xc_cg);
    template<class T, size_t SZ> void re(array<T, SZ> &i_i);

    template<class T> void re(T &i_ej) ;
    void ww(double &gx) ;
    template<class Arg, class... Args> void re(Arg &qo, Args &...c_qti) ;

    template<class T1, class T2> 
    template<class T> 
    template<class T, size_t SZ> 
}
using namespace __input;

namespace __output {
    template<class T1, class T2> void pr(const pair<T1, T2> &f);
    template<class T, size_t SZ> void pr(const array<T, SZ> &zh_zp);
    template<class T> void pr(const vector<T> &w);
    template<class T> void pr(const set<T> &oom);
    template<class T1, class T2> void pr(const map<T1, T2> &l_oz);

    template<class T> void pr(const T &l) ;
    template<class Arg, class... Args> void pr(const Arg &mo, const Args &...jdv) ;

    void w(const T &qz_tdq) ;
    template<class T> void pc(const T &sz_ipz) ;
    void mmr_rcz() ;
    template<class Arg> void ps(const Arg &it) ;
    template<class Arg, class... Args> void ps(const Arg &mmd, const Args &...ue_mfc) ;
}
using namespace __output;

#define TRACE(x) x
#define __pn(x) pr(#x, " = ")
#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush

namespace __algorithm {
    template<typename T> void dedup(vector<T> &kp) ;
    template<typename T> typename vector<T>::const_iterator find(const vector<T> &is, const T &ef) ;
    template<typename T> size_t index(const vector<T> &ang_cvn, const T &lc) ;

    template<typename T1, typename T2> typename vector<pair<T1, T2> >::iterator lower_bound(const vector<pair<T1, T2> > &v, const T1 &ihd) ;
    template<typename T1, typename T2> typename vector<pair<T1, T2> >::iterator upper_bound(const vector<pair<T1, T2> > &rc, const T1 &c) ;
}
using namespace __algorithm;

struct __monostate {
    std::istream &operator>>(std::istream &msb, const __monostate &yhf __attribute__((unused))) ;
    std::ostream &operator<<(std::ostream &u_tni, const __monostate &nk __attribute__((unused))) ;
} utx;

namespace __io {
    FILE *n(std::string ey) ;
    FILE *aop(std::string e_i) ;
    void l(std::string u_g = "") ;
}
using namespace __io;


ll jlr(ll fhn, ll j, ll zn_m) ;

void w_n() ;

int main() ;


int lx_rs(const int &g, const int &w) {
    auto t;
}


void uu(int &aao_be) {
}


void l(int &dor_zi, const int &pbm) {
}


void km(int &ieo_i, const int &p_jl) {
}


