#include<bits/stdc++.h>

using namespace std;
 
 #define ll         long long 
 #define pb         push_back
 #define mp         make_pair
 #define ff         first
 #define ss         second
 #define u_m        unordered_map
 #define p_q        priority_queue
 #define ve         vector  
 #define mod        1000000007  
 #define dub        double

 


 void fastio()
 {
   ios_base::sync_with_stdio();
   cin.tie(NULL);
 }

vector<bool>is_prime;

ve<ll> seive(ll n){
    vector<bool>ip(n+1,true);
    {
    ll i=2;
    while (i*i<n) {
         if(ip[i]==true)
         {
            {
            ll j=i*i;
            while (j<=n) {
                ip[j]=false;
            	j+=i; 
            
            }}
         }
    	i++; 
    
    }}
  is_prime=ip;
 ve<ll>primes;
primes.pb(1);
 {
 ll i=2;
 while (i<ip.size()) {
    if( ip[i]==true)
         primes.pb(i);
 	i++; 
 
 }} 
  
return primes;

}



ve<ll> seg_seive(ll l ,ll r)
{   
    ll root=(ll)sqrt(r);
    ve<ll> primes=seive(root);
    ve<bool> ip((r-l+1),true);
    {
    ll i=1;
    while (i<primes.size()) {
        ll base=( l/primes[i])*primes[i];
        if( base<l)
            base+=primes[i];
       {
       ll j=base;
       while (j<=r) {
            ip[j-l]=false;
       	j+=primes[i]; 
       
       }}
    	i++; 
    
    }}
    ve<ll>seg_primes;
  {
  ll i=0;
  while (i<ip.size()) {
     if(ip[i]==true)
        seg_primes.pb(i+l);
  	i++; 
  
  }}
   return seg_primes;
}

ve<ll> range_prefix_sum( ve<bool>ip){
ve<ll> ps((ll)ps.size());
 ps[0]=1;
 {
 ll i=1;
 while (i<=ps.size()) {
    ps[i]=ps[i-1]+ip[i];
 	i++; 
 
 }} 
return ps;
}


string give_binary(ll n)
{
      if(n==0)
        {
            //dp[n]="0";
            return "0";
        }
       
       if( n%2==0)
       {
        string s=give_binary(n/2);
        s+="0";
       
        return s;
       }
       string s=give_binary(n-1);
       s[s.length( )-1]='1';
       
       return s;
}



 

 
/************************************************************************************************************************************************************************************************************************************************************************************/
/************************************************************************************************************************************************************************************************************************************************************************************/
/************************************************************************************************************************************************************************************************************************************************************************************/
/************************************************************************************************************************************************************************************************************************************************************************************/
/************************************************************************************************************************************************************************************************************************************************************************************/
/************************************************************************************************************************************************************************************************************************************************************************************/
/************************************************************************************************************************************************************************************************************************************************************************************/
/************************************************************************************************************************************************************************************************************************************************************************************/
/************************************************************************************************************************************************************************************************************************************************************************************/





void Solve(ll n , ve<ll>&nums)   
{   
  ll ans=0;
  ll lm=3;
  ll ul=( (2*n)-1);  
  {
  ll i=0;
  while (i<n) {
    ve<ll>mul;
    {
    ll j=nums[i];
    while (j<=ul) {
        if(j>=lm)
            mul.pb(j);
    	j+=nums[i]; 
    
    }}
    {
    ll j=0;
    while (j<mul.size()) {
       ll dj=(nums[i]*(mul[j]/nums[i])-(i+1));
        if( (dj-1) >i && (dj-1)<nums.size()){
            if(nums[dj-1]==(mul[j]/nums[i]))
                 ans++;  
        }


    	j++; 
    
    }}

// for( ll data:mul){
//         printf( "%lld\n",data);
//     }
  	i++; 
  
  }}
    printf("%lld\n",ans);
    return;
    }







int main(){
   
   fastio();
   ll t;
   scanf("%lld",&t); 
   //ve<string>bins=pre_compute();
   while(t--){
      ll n;
      scanf("%lld",&n);
      ve<ll> nums(n);
      {
      ll i=0;
      while (i<n) {
         scanf("%lld",&nums[i]);
      	i++; 
      
      }}
      Solve(n, nums);
  }
  return 0;

} 

